---
title: 适配器模式
date: 2018-01-13 13:58:33
tags:
- 适配器
categories: 设计模式
---
# 结构分析
## 对象适配器模式
![原型图](http://img.my.csdn.net/uploads/201302/28/1362066399_9469.jpg)
Target是跟client客户端挂钩的，Apaptee是适配者，真正要使用的对象方法。但是Target跟Adaptee接口不适合直接对接（可能因为Adaptee无法改源码等原因），所以引入了Adapter角色，它在中间进行适配。它继承Target,保持Adaptee对象作为属性，负责转换。
## 类适配器模式
![原型图](http://img.my.csdn.net/uploads/201303/01/1362099343_7447.jpg)
类适配器模式与对象适配器模式的区别是，他继承了Adaptee，实现Target接口，实现了同样的功能。这样代码会更简洁点，但是就有局限性，因为java，c#等语言不能继承多个的特性，如果Target不是接口，就无法使用此种模式。
## 双向适配器模式
![原型图](http://img.my.csdn.net/uploads/201303/01/1362100282_9857.jpg)
双向适配器模式的主要特性就是同时为双方都提供了适配转换。Target想要调用Adaptee的方法，需要转换，Adaptee想要调用Target的方法，也需要转换，所以双向适配器模式就出现了。此模式在实际开发中很少使用。
## 缺省适配器模式
![原型图](http://img.my.csdn.net/uploads/201303/01/1362101177_9180.jpg)
ServiceInterface定义了大量方法。
ServiceAbstract缺省适配器模式的核心类，使用空方法实现了ServiceInterfac。
ConcreteService具体业务类，是缺省适配器模式的子类，
缺省适配器模式是适配器模式的一种变体，当不需要实现一个接口所提供的所有方法时，提供一个抽象类用空方法实现接口，然后再继承该抽象类override掉需要的方法。

# 主要优点
1. 将目标类与适配者类解耦，引入一个适配器角色来负责中间的转换，无需修改原有的结构。
2. 灵活性和扩展性都非常好，可以很方便的更换适配器，符合开闭原则。
3. 一个对象适配器可以适配多个适配者。
4. 根据理式代换原则，甚至可以适配一个适配者的子类

# 主要缺点
## 适配器模式的缺点如下
1. 对于java,c#等语言中，不支持多重类继承，最多只能适配一个适配者。
2. 适配者类不能为final类。
3. 目标类只能为接口。

## 对象适配器的缺点如下
1. 适配某些适配者的方法时比较麻烦，必要情况下，可以先做个适配者的子类，在子类中负责部分逻辑，然后适配器适配其子类。

# 适用场景
1. 系统当前需求接口与适配者类不是很兼容，但这些类源码缺失。
2. 想要创建一个可以重复使用的类，用于与一些没什么太大的关系的类一起工作。